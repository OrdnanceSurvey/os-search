/**
 * @license osel-search - v0.0.4-republshed - 25-07-2016
 * (c) 2015 Ordnance Survey Limited
 * License: MIT
 */
"use strict";!function(a){return a.module("ngOrderObjectBy",[]).filter("orderObjectBy",function(){return function(b,c,d){function e(a){return!isNaN(parseFloat(a))&&isFinite(a)}function f(a,b){return a[b]}var g=[];return a.forEach(b,function(a,b){a.key=b,g.push(a)}),g.sort(function(a,b){var d,g=c.split(".").reduce(f,a),h=c.split(".").reduce(f,b);return e(g)&&e(h)&&(g=Number(g),h=Number(h)),d=g===h?0:g>h?1:-1}),d&&g.reverse(),g}})}(angular),function(){angular.module("osel-search",["rx","ngOrderObjectBy"])}(),function(){var a=["observeOnScope","$http","rx","$timeout","$filter","$window"],b=function(a,b,c,d,e,f){return{templateUrl:"templates/osel-search.html",scope:{options:"=oselSearch"},link:function(g,h,i){function j(a,b){for(;!a.classList.contains(b);)if(a=a.parentNode,!a||!a.classList)return null;return a}var k=200;// use this if $scope.options.buffer is not set
// ---------- variables setup start -----------
g.options=g.options||{},g.options.providers=g.options.providers||[],g.options.placeholder=g.options.hasOwnProperty("placeholder")?g.options.placeholder:"Start typing to search",g.searchResults={},
// turn $scope.options.providers into a hashmap, with provider.id as the keys
g.searchProviders=g.options.providers.reduce(function(a,b){return a[b.id]=b,a},{});
// ---------- variables setup end -----------
// turn search provider JSON into an rx.Observable, with a URL including the search term
var l=function(a,d){var e=a.url;angular.isFunction(a.url)&&(e=a.url(d));var f={params:angular.copy(a.params),data:angular.copy(a.data),dataType:a.dataType,url:e,method:a.method};
// inject search term into params and data
for(var g in f.params)f.params[g]=f.params[g].replace("%s",d);for(g in f.data)f.data[g]=f.data[g].replace("%s",d);return c.Observable.fromPromise(b(f))},m=function(a,b){
//return rx.Observable.fromCallback(fn)(term);
return c.Observable.create(function(c){try{var d=a.call(this,b);
// if result is a promise, then listen for resolve/reject.  Otherwise, use value immediately
angular.isFunction(d.then)?d.then(function(a){c.onNext(a),c.onCompleted()})["catch"](function(a){c.onError(a)}):(c.onNext(d),c.onCompleted())}catch(e){c.onError(e)}})},n=function(a,b){
// check if provider is 'function' type
// check if provider is 'function' type
return a.hasOwnProperty("fn")?m(a.fn,b):l(a,b)},o=a(g,"searchInput").debounce(g.options.buffer||k).map(function(a){return a.newValue}).distinctUntilChanged();// ignore duplicate searches if value didn't change since last search
// fire off requests to providers based on throttled search term
o.filter(function(a){
// only search on 3+ characters
// reset the search results for each provider whenever input changes
return g.options.providers.forEach(function(a){g.searchResults[a.id]=g.searchResults[a.id]||{},g.searchResults[a.id].providerId=a.id,// need to save the id because orderObjectBy changes Object into an Array
g.searchResults[a.id].results=[]}),a&&a.length&&a.length>2}).subscribe(function(a){var b=g.options.providers.map(function(b){d(function(){g.searchResults[b.id].inProgress=!0,g.searchResults[b.id].results=[],g.searchResults[b.id].error=void 0,g.searchResults[b.id].received=1/0});var c=n(b,a);return c.providerId=b.id,c.term=a,c.sent=new Date,c.config=b,c});b.forEach(function(a){a.subscribe(function(b){d(function(){
// call tranformResponse function if provided
a.config.transformResponse&&(b=a.config.transformResponse.call(this,b)),
// check that response is for the current search term
g.searchInput===a.term&&(g.searchResults[a.providerId].inProgress=!1,g.searchResults[a.providerId].results=b.results,g.searchResults[a.providerId].error="",g.searchResults[a.providerId].sent=a.sent,g.searchResults[a.providerId].received=new Date,
// changes made to scope, so tell angular to digest
g.$$phase||g.$digest())})},function(b){g.searchResults[a.providerId].inProgress=!1,g.searchResults[a.providerId].results=[],g.searchResults[a.providerId].error=b.data?b.data.error:b.data,// TODO check this logic with a real server error
g.searchResults[a.providerId].received=1/0,// needs to be Infinity so that we can sort errors to the right
g.searchResults[a.providerId].sent=a.sent})})}),
// helper function which returns true when any results are available
// ignores errors and inProgress, or empty results
g.resultsAvailable=function(){return g.options.providers.filter(function(a){var b=g.searchResults[a.id];return b.inProgress||b.error||b.results.length>0}).length>0},
// search results visible when false
g.searchHidden=!1,
// hide the search results
g.hideSearch=function(){g.searchHidden=!0},
// call onSelect function if provided.
g.selectResult=function(a,b){b&&b.call(null,a),g.hideSearch(),g.searchInput=a.text};
// set focus to a specific search result.  Need to pass the providerId of the result so we can locate it in the DOM
var p=function(a,b){var c=g.searchResults[b].results.indexOf(a),d=h.find("div[data-provider-id='"+b+"'] .osel-search-result[data-search-result-index='"+c+"']");d[0].focus()},q=function(){var a=h.find("input.osel-search");a[0].focus(),d(
// use the selection properties
a[0].selectionStart?function(){a[0].selectionStart=a[0].selectionEnd=a[0].value.length}:function(){a.val(a.val())})};
// keydown handler from the search input box
g.keyFromInput=function(a){if(40===a.keyCode){var b=e("orderObjectBy")(g.searchResults,"received").filter(function(a){return!a.error&&!a.inProgress&&a.results.length>0});try{p(b[0].results[0],b[0].providerId),a.preventDefault()}catch(c){}}};
// helper function to find neighbouring search result of a given result
// takes into account top/bottom and left/right (doesn't exceed length of list)
var r=function(a,b,c){
// make the ordered array, as is displayed to the user
var d=e("orderObjectBy")(g.searchResults,"received").filter(function(a){return!a.error&&!a.inProgress&&a.results.length>0}),h=d.map(function(a){return a.providerId}),i=$(a).attr("data-provider-id"),j=h.indexOf(i),k=h[j+b];// add the offset to go left or right
0>j+b?k=h[0]:j+b>d.length-1?k=h[d.length-1]:d[k]&&(d[k].inProgress||d[k].error)&&(k=i);var l=f.parseInt($(a).attr("data-search-result-index")),m=l+c;return 0>l+c?m=0:l+c>g.searchResults[k].results.length-1&&(m=g.searchResults[k].results.length-1),{result:g.searchResults[k].results[m],providerId:k}};
// move up/down/left/right from current focused search result
// also listen for enter/esc to select result or hide search results
g.keyFromSearchResult=function(a,b,c,d){var e;// left
// right
// down
// up
// enter
// escape
return 37===a.keyCode?(e=r(f.document.activeElement,-1,0),p(e.result,e.providerId),a.preventDefault()):39===a.keyCode?(e=r(f.document.activeElement,1,0),p(e.result,e.providerId),a.preventDefault()):40===a.keyCode?(e=r(f.document.activeElement,0,1),p(e.result,e.providerId),a.preventDefault()):38===a.keyCode?(0===g.searchResults[c].results.indexOf(b)?q():(e=r(f.document.activeElement,0,-1),p(e.result,e.providerId)),a.preventDefault()):13===a.keyCode?g.selectResult(b,d):27===a.keyCode&&(g.searchHidden=!0),e},
// hide search results if user clicks outdside the searchbox or outside the search results
angular.element(document.querySelector("html")).on("click",function(a){var b=angular.element(a.target);!b||j(b[0],"osel-search")||j(b[0],"osel-search-results")||d(function(){g.searchHidden=!0})})}}};angular.module("osel-search").directive("oselSearch",a.concat([b]))}();