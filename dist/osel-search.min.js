/**
 * @license osel-search - v0.0.1 - 01-07-2015
 * (c) 2015 Ordnance Survey Limited
 * License: MIT
 */
// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.
!function(a,b){var c={"boolean":!1,"function":!0,object:!0,number:!1,string:!1,undefined:!1},a=c[typeof window]&&window||this,d=c[typeof exports]&&exports&&!exports.nodeType&&exports,e=c[typeof module]&&module&&!module.nodeType&&module,f=(e&&e.exports===d&&d,c[typeof global]&&global);!f||f.global!==f&&f.window!==f||(a=f),
// Because of build optimizers
"function"==typeof define&&define.amd?define(["rx","angular","exports"],function(c,d,e){return a.Rx=b(a,e,c,d),a.Rx}):"object"==typeof module&&module&&module.exports==d?module.exports=b(a,module.exports,require("rx"),require("angular")):a.Rx=b(a,{},a.Rx,a.angular)}(this,function(a,b,c,d,e){var f=c.Observable,g=f.prototype,h=f.create,i=c.Disposable.create,j=c.SingleAssignmentDisposable,k=c.CompositeDisposable,l=c.AnonymousObservable,m=c.Scheduler,n=c.helpers.noop,o=(Object.prototype.toString,Array.prototype.slice),p=d.module("rx",[]);/**
   * @ngdoc service
   * @name rx.rx
   *
   * @requires $window
   *
   * @description
   * Factory service that exposes the global `Rx` object to the Angular world.
   */
p.factory("rx",["$window",function(a){return a.Rx||(a.Rx=c),a.Rx}]),/**
  * @ngdoc service
  * @name rx.observeOnSope
  *
  * @requires rx.rx
  *
  * @description
  * An observer function that returns a function for a given `scope`,
  * `watchExpression` and `objectEquality` object. The returned function
  * delegates to an Angular watcher.
  *
  * @param {object} scope Scope object.
  * @param {(string|object)} watchExpression Watch expression.
  * @param {boolean} objectEquality Object to compare for object equality.
  *
  * @return {function} Factory function that creates obersables.
  */
p.factory("observeOnScope",["rx",function(a){return function(b,c,d){return a.Observable.create(function(a){
// Create function to handle old and new Value
function e(b,c){a.onNext({oldValue:c,newValue:b})}
// Returns function which disconnects the $watch expression
return b.$watch(c,e,d)})}}]),g.safeApply=function(a,b){return b=d.isFunction(b)?b:n,this["do"](function(c){a.$$phase||a.$root.$$phase?b(c):a.$apply(function(){b(c)})})},p.config(["$provide",function(a){/**
     * @ngdoc service
     * @name rx.$rootScope
     *
     * @requires $delegate
     *
     * @description
     * `$rootScope` decorator that extends the existing `$rootScope` service
     * with additional methods. These methods are Rx related methods, such as
     * methods to create observables or observable functions.
     */
a.decorator("$rootScope",["$delegate",function(a){return Object.defineProperties(a.constructor.prototype,{/**
         * @ngdoc property
         * @name rx.$rootScope.$toObservable
         *
         * @description
         * Provides a method to create observable methods.
         */
$toObservable:{/**
           * @ngdoc function
           * @name rx.$rootScope.$toObservable#value
           *
           * @description
           * Creates an observable from a watchExpression.
           *
           * @param {(function|string)} watchExpression A watch expression.
           * @param {boolean} objectEquality Compare object for equality.
           *
           * @return {object} Observable.
           */
value:function(a,b){var d=this;return h(function(e){
// Create function to handle old and new Value
function f(a,b){e.onNext({oldValue:b,newValue:a})}
// Returns function which disconnects the $watch expression
var g=c.Disposable.create(d.$watch(a,f,b));return d.$on("$destroy",function(){g.dispose()}),g}).publish().refCount()},/**
           * @ngdoc property
           * @name rx.$rootScope.$toObservable#enumerable
           *
           * @description
           * Enumerable flag.
           */
enumerable:!1,configurable:!0,writable:!0},/**
         * @ngdoc property
         * @name rx.$rootScope.$eventToObservable
         *
         * @description
         * Provides a method to create observable methods.
         */
$eventToObservable:{/**
           * @ngdoc function
           * @name rx.$rootScope.$eventToObservable#value
           *
           * @description
           * Creates an Observable from an event which is fired on the local $scope.
           * Expects an event name as the only input parameter.
           *
           * @param {string} event name
           *
           * @return {object} Observable object.
           */
value:function(a){var b=this;return h(function(c){function d(){c.onNext({event:arguments[0],additionalArguments:o.call(arguments,1)})}
// Returns function which disconnects from the event binding
var e=i(b.$on(a,d));return b.$on("$destroy",function(){e.isDisposed||e.dispose()}),e}).publish().refCount()},/**
           * @ngdoc property
           * @name rx.$rootScope.$eventToObservable#enumerable
           *
           * @description
           * Enumerable flag.
           */
enumerable:!1,configurable:!0,writable:!0},/**
         * @ngdoc property
         * @name rx.$rootScope.$createObservableFunction
         *
         * @description
         * Provides a method to create obsersables from functions.
         */
$createObservableFunction:{/**
           * @ngdoc function
           * @name rx.$rootScope.$createObservableFunction#value
           *
           * @description
           * Creates an observable from a given function.
           *
           * @param {string} functionName A function name to observe.
           * @param {function} listener A listener function that gets executed.
           *
           * @return {function} Remove listener function.
           */
value:function(a,b){var c=this;return h(function(d){return c[a]=function(){b?d.onNext(b.apply(this,arguments)):1===arguments.length?d.onNext(arguments[0]):d.onNext(arguments)},function(){
// Remove our listener function from the scope.
delete c[a]}}).publish().refCount()},/**
           * @ngdoc property
           * @name rx.$rootScope.$createObservableFunction#enumerable
           *
           * @description
           * Enumerable flag.
           */
enumerable:!1,configurable:!0,writable:!0},/**
         * @ngdoc function
         * @name rx.$rootScope.$digestObservables#value
         *
         * @description
         * Digests the specified observables when they produce new values.
         * The scope variable specified by the observable's key
         *   is set to the new value.
         *
         * @param {object} obj A map where keys are scope properties
         *   and values are observables.
         *
         * @return {boolean} Reference to obj.
         */
$digestObservables:{value:function(a){var b=this;return d.map(a,function(a,c){return a.digest(b,c)}).publish().refCount()},/**
           * @ngdoc property
           * @name rx.$rootScope.digestObservables#enumerable
           *
           * @description
           * Enumerable flag.
           */
enumerable:!1,configurable:!0,writable:!0}}),a}])}]),p.run(["$parse",function(a){g.digest=function(b,c){var d=this;return new l(function(e){var f=a(c).assign,g=new j;return g.setDisposable(d.subscribe(function(a){b.$$phase?f(b,a):b.$apply(f(b,a))},e.onError.bind(e),e.onCompleted.bind(e))),b.$on("$destroy",g.dispose.bind(g)),g})}}]);c.ScopeScheduler=function(){function a(a,b){var c=this,e=new j;return d(e,c,b,a),e}function b(a,b,e){var f=this,g=c.Scheduler.normalize(b);if(0===g)return f.scheduleWithState(a,e);var h=new j,l=setTimeout(function(){d(h,f,e,a)},g);return new k(h,i(function(){clearTimeout(l)}))}function d(a,b,c,d){function e(){!a.isDisposed&&a.setDisposable(c(b,d))}b._scope.$$phase||b._scope.$root.$$phase?e():b._scope.$apply(e)}function e(a,b,c){return this.scheduleWithRelativeAndState(a,b-this.now(),c)}var f=Date.now||+new Date;return function(c){var d=new m(f,a,b,e);return d._scope=c,d}}(),c.manageScope=function(a){return function(b){var d=b;return new l(function(b){var e=new j,f=c.ScopeScheduler(a);return e.setDisposable(d.observeOn(f).subscribe(b.onNext.bind(b),b.onError.bind(b),b.onCompleted.bind(b))),a.$on("$destroy",function(){e.dispose(),delete e}),e})}};return c}),function(a){return a.module("ngOrderObjectBy",[]).filter("orderObjectBy",function(){return function(b,c,d){function e(a,b){return a[b]}var f=[];return a.forEach(b,function(a){f.push(a)}),f.sort(function(a,b){var d,f=c.split(".").reduce(e,a),g=c.split(".").reduce(e,b);return d=f===g?0:f>g?1:-1}),d&&f.reverse(),f}})}(angular);var module=angular.module("osel-search",["rx","ngOrderObjectBy"]),dependencies=["observeOnScope","$http","rx","$timeout"],oselSearchDirective=function(a,b,c,d){return{templateUrl:"templates/osel-search.html",scope:{options:"=oselSearch"},link:function(e,f,g){var h=200;// use this if $scope.options.buffer is not set
e.options=e.options||{},e.options.providers=e.options.providers||[],e.options.placeholder=e.options.hasOwnProperty("placeholder")?e.options.placeholder:"Start typing to search",e.searchResults={},
// turn $scope.options.providers into a hashmap, with provider.id as the keys
e.searchProviders=e.options.providers.reduce(function(a,b){return a[b.id]=b,a},{});
// turn search provider JSON into an rx.Observable, with a URL including the search term
var i=function(a,d){var e={params:angular.copy(a.params),data:angular.copy(a.data),dataType:a.dataType,url:a.url,method:a.method};
// inject search term into params and data
for(var f in e.params)e.params[f]=e.params[f].replace("%s",d);for(f in e.data)e.data[f]=e.data[f].replace("%s",d);return c.Observable.fromPromise(b(e))},j=function(a,b){
//return rx.Observable.fromCallback(fn)(term);
return c.Observable.create(function(c){try{c.onNext(a.call(this,b)),c.onCompleted()}catch(d){console.error(d),c.onError(d)}})},k=function(a,b){
// check if provider is 'function' type
// check if provider is 'function' type
return a.hasOwnProperty("fn")?j(a.fn,b):i(a,b)},l=a(e,"searchInput").debounce(e.options.buffer||h).map(function(a){return a.newValue}).distinctUntilChanged();// ignore duplicate searches if value didn't change since last search
// fire off requests to providers based on throttled search term
l.filter(function(a){
// only search on 3+ characters
// reset the search results for each provider whenever input changes
return e.options.providers.forEach(function(a){e.searchResults[a.id]=e.searchResults[a.id]||{},e.searchResults[a.id].providerId=a.id,// need to save the id because orderObjectBy changes Object into an Array
e.searchResults[a.id].results=[]}),a&&a.length&&a.length>2}).subscribe(function(a){var b=e.options.providers.map(function(b){d(function(){e.searchResults[b.id].inProgress=!0,e.searchResults[b.id].results=[],e.searchResults[b.id].error=void 0,e.searchResults[b.id].received=1/0});var c=k(b,a);return c.providerId=b.id,c.term=a,c.sent=new Date,c.config=b,c});b.forEach(function(a){a.subscribe(function(b){d(function(){
// call tranformResponse function if provided
a.config.transformResponse&&(b=a.config.transformResponse.call(this,b)),
// check that response is for the current search term
e.searchInput===a.term&&(e.searchResults[a.providerId].inProgress=!1,e.searchResults[a.providerId].results=b.results,e.searchResults[a.providerId].error="",e.searchResults[a.providerId].sent=a.sent,e.searchResults[a.providerId].received=new Date,
// changes made to scope, so tell angular to digest
e.$$phase||e.$digest())})},function(b){e.searchResults[a.providerId].inProgress=!1,e.searchResults[a.providerId].results=[],e.searchResults[a.providerId].error=b.data.error||b.data,// TODO check this logic with a real server error
e.searchResults[a.providerId].received=1/0,// needs to be Infinity so that we can sort errors to the right
e.searchResults[a.providerId].sent=a.sent})})}),e.resultsAvailable=function(){return e.options.providers.filter(function(a){var b=e.searchResults[a.id];return b.inProgress||b.error||b.results.length>0}).length>0},
// search results visible when false
e.searchHidden=!1,
// hide the search results
e.hideSearch=function(){e.searchHidden=!0},
// call onSelect function if provided.  Pass the hideSearch handler so the function may call it
e.selectResult=function(a,b){b&&b.call(null,a,e.hideSearch)}}}};angular.module("osel-search").directive("oselSearch",dependencies.concat([oselSearchDirective]));