/**
 * @license osel-search - v0.0.3 - 30-03-2016
 * (c) 2015 Ordnance Survey Limited
 * License: MIT
 */
// Copyright (c) Microsoft. All rights reserved. See License.txt in the project root for license information.
!function(a,b){var c={"boolean":!1,"function":!0,object:!0,number:!1,string:!1,undefined:!1},a=c[typeof window]&&window||this,d=c[typeof exports]&&exports&&!exports.nodeType&&exports,e=c[typeof module]&&module&&!module.nodeType&&module,f=(e&&e.exports===d&&d,c[typeof global]&&global);!f||f.global!==f&&f.window!==f||(a=f),
// Because of build optimizers
"function"==typeof define&&define.amd?define(["rx","angular","exports"],function(c,d,e){return a.Rx=b(a,e,c,d),a.Rx}):"object"==typeof module&&module&&module.exports==d?module.exports=b(a,module.exports,require("rx"),require("angular")):a.Rx=b(a,{},a.Rx,a.angular)}(this,function(a,b,c,d,e){function f(a){return function(){try{return a.apply(this,arguments)}catch(b){return i.e=b,i}}}function g(a){if(!d.isFunction(a))throw new TypeError("fn must be a function");return f(a)}function h(){}var i={e:{}},j=d.module("rx",[]);/**
   * @ngdoc service
   * @name rx.rx
   *
   * @requires $window
   *
   * @description
   * Factory service that exposes the global `Rx` object to the Angular world.
   */
j.factory("rx",["$window",function(a){a.Rx||(a.Rx=c);var b=function(a){function b(b,c,d){this._self=b,this._name=c,this._fn=d,a.call(this)}function e(a,b){this._self=a,this._name=b,this.isDisposed=!1}return c.internals.inherits(b,a),b.prototype.subscribeCore=function(a){var b=this._fn;return this._self[this._name]=function(){for(var c=arguments.length,e=new Array(c),f=0;c>f;f++)e[f]=arguments[f];if(d.isFunction(b)){var h=g(b).apply(this,e);if(h===i)return a.onError(h.e);a.onNext(h)}else 1===e.length?a.onNext(e[0]):a.onNext(e)},new e(this._self,this._name)},e.prototype.dispose=function(){this.isDisposed||(this.isDisposed=!0,delete this._self[this._name])},b}(c.ObservableBase);return c.createObservableFunction=function(a,c,d){return new b(a,c,d).publish().refCount()},a.Rx}]),/**
  * @ngdoc service
  * @name rx.observeOnSope
  *
  * @requires rx.rx
  *
  * @description
  * An observer function that returns a function for a given `scope`,
  * `watchExpression` and `objectEquality` object. The returned function
  * delegates to an Angular watcher.
  *
  * @param {object} scope Scope object.
  * @param {(string|object)} watchExpression Watch expression.
  * @param {boolean} objectEquality Object to compare for object equality.
  *
  * @return {function} Factory function that creates obersables.
  */
j.factory("observeOnScope",["rx",function(a){var b=function(b){function c(a,c,d){this._scope=a,this._expr=c,this._eq=d,b.call(this)}function d(a){return function(b,c){a.onNext({oldValue:c,newValue:b})}}function e(a){this._fn=a,this.isDisposed=!1}return a.internals.inherits(c,b),c.prototype.subscribeCore=function(a){return new e(this._scope.$watch(this._expr,d(a),this._eq))},e.prototype.dispose=function(){this.isDisposed||(this._fn(),this.isDisposed=!0)},c}(a.ObservableBase);return function(a,c,d){return new b(a,c,d)}}]),c.Observable.prototype.safeApply=function(a,b,c,e){return b=d.isFunction(b)?b:h,c=d.isFunction(c)?c:h,e=d.isFunction(e)?e:h,this.takeWhile(function(){return!a.$$destroyed}).tap(function(c){a.$$phase||a.$root.$$phase?b(c):a.$apply(function(){b(c)})},function(b){a.$$phase||a.$root.$$phase?c(b):a.$apply(function(){c(b)})},function(){a.$$phase||a.$root.$$phase?e():a.$apply(function(){e()})})},j.config(["$provide",function(a){/**
     * @ngdoc service
     * @name rx.$rootScope
     *
     * @requires $delegate
     *
     * @description
     * `$rootScope` decorator that extends the existing `$rootScope` service
     * with additional methods. These methods are Rx related methods, such as
     * methods to create observables or observable functions.
     */
a.decorator("$rootScope",["$delegate","rx",function(a,b){return Object.defineProperties(a.constructor.prototype,{/**
           * @ngdoc property
           * @name rx.$rootScope.$toObservable
           *
           * @description
           * Provides a method to create observable methods.
           */
$toObservable:{/**
               * @ngdoc function
               * @name rx.$rootScope.$toObservable#value
               *
               * @description
               * Creates an observable from a watchExpression.
               *
               * @param {(function|string)} watchExpression A watch expression.
               * @param {boolean} objectEquality Compare object for equality.
               *
               * @return {object} Observable.
               */
value:function(a,c){var d=this;return b.Observable.create(function(e){
// Create function to handle old and new Value
function f(a,b){e.onNext({oldValue:b,newValue:a})}
// Returns function which disconnects the $watch expression
var g=b.Disposable.create(d.$watch(a,f,c));return d.$on("$destroy",function(){g.dispose()}),g}).publish().refCount()},/**
               * @ngdoc property
               * @name rx.$rootScope.$toObservable#enumerable
               *
               * @description
               * Enumerable flag.
               */
enumerable:!1,configurable:!0,writable:!0},/**
           * @ngdoc property
           * @name rx.$rootScope.$toObservableCollection
           *
           * @description
           * Provides a method to create observable methods.
           */
$toObservableCollection:{/**
               * @ngdoc function
               * @name rx.$rootScope.$toObservableCollection#value
               *
               * @description
               * Creates an observable from a watchExpression.
               *
               * @param {(function|string)} watchExpression A watch expression.
               *
               * @return {object} Observable.
               */
value:function(a){var c=this;return b.Observable.create(function(d){
// Create function to handle old and new Value
function e(a,b){d.onNext({oldValue:b,newValue:a})}
// Returns function which disconnects the $watch expression
var f=b.Disposable.create(c.$watchCollection(a,e));return c.$on("$destroy",function(){f.dispose()}),f}).publish().refCount()},/**
               * @ngdoc property
               * @name rx.$rootScope.$toObservableCollection#enumerable
               *
               * @description
               * Enumerable flag.
               */
enumerable:!1,configurable:!0,writable:!0},/**
           * @ngdoc property
           * @name rx.$rootScope.$toObservableGroup
           *
           * @description
           * Provides a method to create observable methods.
           */
$toObservableGroup:{/**
               * @ngdoc function
               * @name rx.$rootScope.$toObservableGroup#value
               *
               * @description
               * Creates an observable from a watchExpressions.
               *
               * @param {(function|string)} watchExpressions A watch expression.
               *
               * @return {object} Observable.
               */
value:function(a){var c=this;return b.Observable.create(function(d){
// Create function to handle old and new Value
function e(a,b){d.onNext({oldValue:b,newValue:a})}
// Returns function which disconnects the $watch expression
var f=b.Disposable.create(c.$watchGroup(a,e));return c.$on("$destroy",function(){f.dispose()}),f}).publish().refCount()},/**
               * @ngdoc property
               * @name rx.$rootScope.$toObservableGroup#enumerable
               *
               * @description
               * Enumerable flag.
               */
enumerable:!1,configurable:!0,writable:!0},/**
         * @ngdoc property
         * @name rx.$rootScope.$eventToObservable
         *
         * @description
         * Provides a method to create observable methods.
         */
$eventToObservable:{/**
           * @ngdoc function
           * @name rx.$rootScope.$eventToObservable#value
           *
           * @description
           * Creates an Observable from an event which is fired on the local $scope.
           * Expects an event name as the only input parameter.
           *
           * @param {string} event name
           *
           * @return {object} Observable object.
           */
value:function(a,c){var e=this;return b.Observable.create(function(f){function h(){for(var a=arguments.length,b=new Array(a),e=0;a>e;e++)b[e]=arguments[e];if(d.isFunction(c)){var h=g(c).apply(null,b);if(h===i)return f.onError(h.e);f.onNext(h)}else 1===b.length?f.onNext(b[0]):f.onNext(b)}
// Returns function which disconnects from the event binding
var j=b.Disposable.create(e.$on(a,h));return e.$on("$destroy",function(){j.dispose()}),j}).publish().refCount()},/**
           * @ngdoc property
           * @name rx.$rootScope.$eventToObservable#enumerable
           *
           * @description
           * Enumerable flag.
           */
enumerable:!1,configurable:!0,writable:!0},/**
         * @ngdoc property
         * @name rx.$rootScope.$createObservableFunction
         *
         * @description
         * Provides a method to create obsersables from functions.
         */
$createObservableFunction:{/**
           * @ngdoc function
           * @name rx.$rootScope.$createObservableFunction#value
           *
           * @description
           * Creates an observable from a given function.
           *
           * @param {string} functionName A function name to observe.
           * @param {function} listener A listener function that gets executed.
           *
           * @return {function} Remove listener function.
           */
value:function(a,c){return b.createObservableFunction(this,a,c)},/**
           * @ngdoc property
           * @name rx.$rootScope.$createObservableFunction#enumerable
           *
           * @description
           * Enumerable flag.
           */
enumerable:!1,configurable:!0,writable:!0},/**
         * @ngdoc function
         * @name rx.$rootScope.$digestObservables#value
         *
         * @description
         * Digests the specified observables when they produce new values.
         * The scope variable / assignable expression specified by the observable's key
         *   is set to the new value.
         *
         * @param {object.<string, Rx.Observable>} obj A map where keys are scope properties
         *   (assignable expressions) and values are observables.
         *
         * @return {Rx.Observable.<{observable: Rx.Observable, expression: string, value: object}>}
         *   Observable of change objects.
         */
$digestObservables:{value:function(a){var c=this;return b.Observable.pairs(a).flatMap(function(a){return a[1].digest(c,a[0]).map(function(b){return{observable:a[1],expression:a[0],value:b}})}).publish().refCount()},/**
           * @ngdoc property
           * @name rx.$rootScope.digestObservables#enumerable
           *
           * @description
           * Enumerable flag.
           */
enumerable:!1,configurable:!0,writable:!0}}),a}])}]),j.run(["$parse",function(a){var b=function(b){function e(a,c,d){this.source=a,this.$scope=c,this.prop=d,b.call(this)}return c.internals.inherits(e,b),e.prototype.subscribeCore=function(b){var e=a(this.prop).assign;if(!e)return b.onError(new Error("Property or expression is not assignable."));var f=new c.SingleAssignmentDisposable;return f.setDisposable(this.source.subscribe(new d(b,this.$scope,e))),this.$scope.$on("$destroy",function(){f.dispose()}),f},e}(c.ObservableBase),d=function(a){function b(b,c,d){this.o=b,this.$scope=c,this.propSetter=d,a.call(this)}return c.internals.inherits(b,a),b.prototype.next=function(a){if(this.$scope.$$phase)this.propSetter(this.$scope,a);else{var b=this;this.$scope.$apply(function(){b.propSetter(b.$scope,a)})}this.o.onNext(a)},b.prototype.error=function(a){this.o.onError(a)},b.prototype.completed=function(){this.o.onCompleted()},b}(c.internals.AbstractObserver);c.Observable.prototype.digest=function(a,c){return new b(this,a,c)}}]);c.ScopeScheduler=function(a){function b(b){this.$scope=b,a.call(this)}return c.internals.inherits(b,a),b.prototype.schedule=function(a,b){if(this.$scope.$$destroyed)return c.Disposable.empty;var d=new c.SingleAssignmentDisposable,e=this.$scope;e.$$phase||e.$root.$$phase?d.setDisposable(c.Disposable._fixup(a(b))):e.$apply.call(e,function(){d.setDisposable(c.Disposable._fixup(a(b)))})},b.prototype._scheduleFuture=function(a,b,d){if(this.$scope.$$destroyed)return c.Disposable.empty;var e=new c.SingleAssignmentDisposable,f=this.$scope,g=setTimeout(function(){return f.$$destroyed||e.isDisposed?clearTimeout(g):void(f.$$phase||f.$root.$$phase?e.setDisposable(c.Disposable._fixup(a(d))):f.$apply.call(f,function(){e.setDisposable(c.Disposable._fixup(a(d)))}))},b);return new c.BinaryDisposable(e,c.Disposable.create(function(){clearTimeout(g)}))},b.prototype.schedulePeriodic=function(a,b,d){if(this.$scope.$$destroyed)return c.Disposable.empty;b=c.Scheduler.normalize(b);var e=this.$scope,f=a,g=setInterval(function(){return e.$$destroyed?clearInterval(g):void(e.$$phase||e.$root.$$phase?f=d(f):e.$apply.call(e,function(){f=d(f)}))},b);return c.Disposable.create(function(){clearInterval(g)})},b}(c.Scheduler);return c}),function(a){return a.module("ngOrderObjectBy",[]).filter("orderObjectBy",function(){return function(b,c,d){function e(a){return!isNaN(parseFloat(a))&&isFinite(a)}function f(a,b){return a[b]}var g=[];return a.forEach(b,function(a,b){a.key=b,g.push(a)}),g.sort(function(a,b){var d,g=c.split(".").reduce(f,a),h=c.split(".").reduce(f,b);return e(g)&&e(h)&&(g=Number(g),h=Number(h)),d=g===h?0:g>h?1:-1}),d&&g.reverse(),g}})}(angular);var module=angular.module("osel-search",["rx","ngOrderObjectBy"]),dependencies=["observeOnScope","$http","rx","$timeout","$filter","$window"],oselSearchDirective=function(a,b,c,d,e,f){return{templateUrl:"templates/osel-search.html",scope:{options:"=oselSearch"},link:function(g,h,i){var j=200;// use this if $scope.options.buffer is not set
// ---------- variables setup start -----------
g.options=g.options||{},g.options.providers=g.options.providers||[],g.options.placeholder=g.options.hasOwnProperty("placeholder")?g.options.placeholder:"Start typing to search",g.searchResults={},
// turn $scope.options.providers into a hashmap, with provider.id as the keys
g.searchProviders=g.options.providers.reduce(function(a,b){return a[b.id]=b,a},{});
// ---------- variables setup end -----------
// turn search provider JSON into an rx.Observable, with a URL including the search term
var k=function(a,d){var e={params:angular.copy(a.params),data:angular.copy(a.data),dataType:a.dataType,url:a.url,method:a.method};
// inject search term into params and data
for(var f in e.params)e.params[f]=e.params[f].replace("%s",d);for(f in e.data)e.data[f]=e.data[f].replace("%s",d);return c.Observable.fromPromise(b(e))},l=function(a,b){
//return rx.Observable.fromCallback(fn)(term);
return c.Observable.create(function(c){try{c.onNext(a.call(this,b)),c.onCompleted()}catch(d){console.error(d),c.onError(d)}})},m=function(a,b){
// check if provider is 'function' type
// check if provider is 'function' type
return a.hasOwnProperty("fn")?l(a.fn,b):k(a,b)},n=a(g,"searchInput").debounce(g.options.buffer||j).map(function(a){return a.newValue}).distinctUntilChanged();// ignore duplicate searches if value didn't change since last search
// fire off requests to providers based on throttled search term
n.filter(function(a){
// only search on 3+ characters
// reset the search results for each provider whenever input changes
return g.options.providers.forEach(function(a){g.searchResults[a.id]=g.searchResults[a.id]||{},g.searchResults[a.id].providerId=a.id,// need to save the id because orderObjectBy changes Object into an Array
g.searchResults[a.id].results=[]}),a&&a.length&&a.length>2}).subscribe(function(a){var b=g.options.providers.map(function(b){d(function(){g.searchResults[b.id].inProgress=!0,g.searchResults[b.id].results=[],g.searchResults[b.id].error=void 0,g.searchResults[b.id].received=1/0});var c=m(b,a);return c.providerId=b.id,c.term=a,c.sent=new Date,c.config=b,c});b.forEach(function(a){a.subscribe(function(b){d(function(){
// call tranformResponse function if provided
a.config.transformResponse&&(b=a.config.transformResponse.call(this,b)),
// check that response is for the current search term
g.searchInput===a.term&&(g.searchResults[a.providerId].inProgress=!1,g.searchResults[a.providerId].results=b.results,g.searchResults[a.providerId].error="",g.searchResults[a.providerId].sent=a.sent,g.searchResults[a.providerId].received=new Date,
// changes made to scope, so tell angular to digest
g.$$phase||g.$digest())})},function(b){g.searchResults[a.providerId].inProgress=!1,g.searchResults[a.providerId].results=[],g.searchResults[a.providerId].error=b.data.error||b.data,// TODO check this logic with a real server error
g.searchResults[a.providerId].received=1/0,// needs to be Infinity so that we can sort errors to the right
g.searchResults[a.providerId].sent=a.sent})})}),
// helper function which returns true when any results are available
// ignores errors and inProgress, or empty results
g.resultsAvailable=function(){return g.options.providers.filter(function(a){var b=g.searchResults[a.id];return b.inProgress||b.error||b.results.length>0}).length>0},
// search results visible when false
g.searchHidden=!1,
// hide the search results
g.hideSearch=function(){g.searchHidden=!0},
// call onSelect function if provided.
g.selectResult=function(a,b){b&&b.call(null,a),g.hideSearch(),g.searchInput=a.text};
// set focus to a specific search result.  Need to pass the providerId of the result so we can locate it in the DOM
var o=function(a,b){var c=g.searchResults[b].results.indexOf(a),d=h.find("div[data-provider-id='"+b+"'] .osel-search-result[data-search-result-index='"+c+"']");d[0].focus()},p=function(){var a=h.find("input.osel-search");a[0].focus(),d(
// use the selection properties
a[0].selectionStart?function(){a[0].selectionStart=a[0].selectionEnd=a[0].value.length}:function(){a.val(a.val())})};
// keydown handler from the search input box
g.keyFromInput=function(a){if(40===a.keyCode){var b=e("orderObjectBy")(g.searchResults,"received").filter(function(a){return!a.error&&!a.inProgress&&a.results.length>0});try{o(b[0].results[0],b[0].providerId),a.preventDefault()}catch(c){}}};
// helper function to find neighbouring search result of a given result
// takes into account top/bottom and left/right (doesn't exceed length of list)
var q=function(a,b,c){
// make the ordered array, as is displayed to the user
var d=e("orderObjectBy")(g.searchResults,"received").filter(function(a){return!a.error&&!a.inProgress&&a.results.length>0}),h=d.map(function(a){return a.providerId}),i=$(a).attr("data-provider-id"),j=h.indexOf(i),k=h[j+b];// add the offset to go left or right
0>j+b?k=h[0]:j+b>d.length-1?k=h[d.length-1]:d[k]&&(d[k].inProgress||d[k].error)&&(k=i);var l=f.parseInt($(a).attr("data-search-result-index")),m=l+c;return 0>l+c?m=0:l+c>g.searchResults[k].results.length-1&&(m=g.searchResults[k].results.length-1),{result:g.searchResults[k].results[m],providerId:k}};
// move up/down/left/right from current focused search result
// also listen for enter/esc to select result or hide search results
g.keyFromSearchResult=function(a,b,c,d){var e;// left
// right
// down
// up
// enter
// escape
return 37===a.keyCode?(e=q(f.document.activeElement,-1,0),o(e.result,e.providerId),a.preventDefault()):39===a.keyCode?(e=q(f.document.activeElement,1,0),o(e.result,e.providerId),a.preventDefault()):40===a.keyCode?(e=q(f.document.activeElement,0,1),o(e.result,e.providerId),a.preventDefault()):38===a.keyCode?(0===g.searchResults[c].results.indexOf(b)?p():(e=q(f.document.activeElement,0,-1),o(e.result,e.providerId)),a.preventDefault()):13===a.keyCode?g.selectResult(b,d):27===a.keyCode&&(g.searchHidden=!0),e},
// hide search results if user clicks outdside the searchbox or outside the search results
$("html").on("click",function(a){var b=$(a.target);b.closest(".osel-search").length||b.closest(".osel-search-results").length||d(function(){g.searchHidden=!0})})}}};angular.module("osel-search").directive("oselSearch",dependencies.concat([oselSearchDirective]));